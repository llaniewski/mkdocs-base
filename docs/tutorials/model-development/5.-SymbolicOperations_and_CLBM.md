---
title: Symbolic Operations and CLBM
author: Grzegorz Gruszczynski
header-includes:
   - \usepackage{bbm}
   - \usepackage{amsmath, amsthm, amsfonts, amssymb}
date: "February 27, 2019"
output: html_document
---

# Symbolic Operations and CLBM

!!! warning "Before start, it is assumed that the reader is already familiar with:"
		* Basic model creation in the TCLB code, see [first tutorial](/tutorials/model-development/1.-finite-difference-wave-equation)
    * Basics of LB physics, see [SRT LBM](/tutorials/model-development/2.-D2Q9-Single-Relexation-Time) and [DDF Heat Transfer](/tutorials/model-development/4.-D2Q9-HeatTransfer)

!!! success "We will cover following topics:"
    * Symbolic computations (within) TCLB.
    * Heat transfer on D2Q9 lattice using Central Moments (CM) a.k.a. Cascaded LBM. 
  		This is an enhancement to the [previous tutorial](/tutorials/model-development/4.-D2Q9-HeatTransfer), where the SRT collision was performed.

## Notion of moments

The raw and central moments are introduced based on the work of Geier et al. [^5] as,

$$ k_{mn} = \sum_{\alpha}(e_{\alpha x})^m ( e_{\alpha y})^n \Psi_{\alpha} $$

while the central moments are calculated in a moving reference frame i.e., with respect to the fluid velocity:
$$ \tilde{k}_{mn} = \sum_{\alpha} ( e_{\alpha x} - u_x)^m ( e_{\alpha y} - u_y)^n \Psi_{\alpha} $$

where \( \Psi_{\alpha} \) is the distribution function of interest (either hydrodynamic or enthalpy).

Alternatively, formerly equations can be expressed by matrix transformations [^1][^2][^3][^4].
!!! note
		Raw moments are obtained from distribution functions through \( \boldsymbol{\Upsilon} = \mathbb{M} \boldsymbol{g} \). 
		Central moments are derived from raw moments by \( \boldsymbol{\tilde{\Upsilon}}= \mathbb{N} \boldsymbol{\Upsilon} \). 
		It is important to notice that \( \mathbb{M} \) is a fixed matrix while \( \mathbb{N} \) depends on the fluid velocity, \( \textbf{u} \). 

The form of the matrices can be found
[here](https://github.com/CFD-GO/TCLB_tools/blob/master/Python/symbolic_tools/SymbolicCollisions/core/cm_symbols.py).
The resulting order of the central moments is,

$$
\boldsymbol{\tilde{\Upsilon}} = 
[\tilde{k}_{00}, \tilde{k}_{10}, \tilde{k}_{01}, \tilde{k}_{20}, \tilde{k}_{02}, \tilde{k}_{11}, \tilde{k}_{21}, \tilde{k}_{12}, \tilde{k}_{22}]^\top.
$$

The physical interpretation of the raw, zeroth order moments of the hydrodynamic and enthalpy DF corresponds to the values of density, \( \rho \), and enthalpy \( H=\rho c_p T \). For simplicity we take \( cp=1=const \) in the remainder of the tutorial.

$$
\begin{eqnarray} 
\rho &=& k_{00} = \sum_\alpha f_\alpha, \\
\rho H &=& k_{00}^H = \sum_\alpha h_\alpha,
\end{eqnarray}
$$

The macroscopic fluid momentum is the first raw moment of the hydrodynamic DF and has a dependency on the forcing term \( \mathbf{F} \).

$$
\begin{eqnarray}
\rho \textbf{u} =
\begin{bmatrix}
	u_{x} \\
	u_{y} \\
\end{bmatrix}
=
\begin{bmatrix}
	k_{10} \\
	k_{01} \\
\end{bmatrix}
= \sum_\alpha f_\alpha \textbf{e}_\alpha + \frac{\textbf{F}}{2 \rho} \delta t.
\end{eqnarray}
$$

### Collision in the Central Moment Space

The collision process and application of forcing terms is conducted in central moment space to improve computational efficiency [^2][^3],

$$
\begin{eqnarray}
% hydrodynamics
\boldsymbol{\tilde{\Upsilon}}^{*}(\textbf{x}, t)& = & 
(\mathbb{1} - \mathbb{S})\boldsymbol{\tilde{\Upsilon}} + \mathbb{S} \boldsymbol{\tilde{\Upsilon}}^{eq}  + (\mathbb{1} - \mathbb{S}/2)\tilde{\textbf{F}}, \\
% heat
\boldsymbol{\tilde{\Upsilon}}^{H,*}(\textbf{x}, t)& = & 
(\mathbb{1} - \mathbb{S}^{H}) \boldsymbol{\tilde{\Upsilon}}^H + \mathbb{S}^{H} \boldsymbol{\tilde{\Upsilon}}^{H, eq}
 \label{eq:pf_collision_streaming}.
\end{eqnarray}
$$

The relaxation matrices, \( \mathbb{S} \) and \( \mathbb{S}^{H} \), have a diagonal form specified as,

$$
\begin{eqnarray}
\mathbb{S}& = &diag\left(
[s_0, s_1, s_1],
\begin{bmatrix}
	s_{+}, & s_{-} \\
	s_{-}, & s_{+} \\
\end{bmatrix},
[s_\nu , s_3, s_3, s_4]
\right),  \label{eq:S_relaxation_matrix}
\\
\mathbb{S}^{H}& = &diag\left( 
[s_0^{H}, s_k^{H}, s_k^{H},s_2^{H}, s_2^{H}, s_2^{H} , s_3^{H}, s_3^{H}, s_4^{H}]
\right),  \label{eq:S_phi_relaxation_matrix}
\end{eqnarray}
$$ 

where \( s_{+}  = (s_b + s_v)/2 \) and \( s_{-}  = (s_b - s_v)/2 \).
Following the Chapman-Enskog expansion, the kinematic and bulk viscosities are used to calculate corresponding relaxation frequencies \( s_v \) and \( s_b \),

$$
\begin{eqnarray}
s_v = \frac{1}{\tau} = \frac{1}{\frac{\nu}{c_s^2 \delta t } + 1/2}, \\
s_b = \frac{1}{\tau_b} = \frac{1}{\frac{\zeta}{c_s^2 \delta t } + 1/2}.
\end{eqnarray}
$$

The bulk relaxation rate is specified as, \( s_b =1 \). Such an approach results in a reduction of non-physical pressure oscillations, 
giving a *bulk equilibrium* after each collision and a more stable model. To satisfy conservation laws for density and momentum, the zeroth and first order relaxation constants are set to unity, \( s_0 = s_1 = 1 \).
For this study, the tunable relaxation frequencies are specified as,  \( s_3 = s_4 =1 \). 

In the case of the Enthalpy DF, the relaxation frequency, \( s_v \), is replaced by,

$$
\begin{eqnarray}
s_k^{H} = \frac{1}{\tau_{k}} = \frac{1}{\frac{k}{c_s^2 \delta t } + 1/2}.
\end{eqnarray}
$$

Here, \( s_k^{H} \) is used to relax the first moments only (see [^2]) while the remainder are conserved by setting the relaxation frequencies to unity, \( s_0^{H} = s_2^{H} = s_3^{H} =s_4^{H} = 1 \).

#### streaming

To perform the streaming step, the relaxed, post-collision central moments need to be transformed back into the velocity distribution space and streamed to neighbours,
$$
\begin{eqnarray}
% hydrodynamics
f_{\alpha}(\textbf{x} + \textbf{e}\delta t, t + \delta t ) 
& = & 
\mathbb{M}^{-1} \mathbb{N}^{-1} \boldsymbol{\tilde{\Upsilon}}^{*}_{\alpha}(\textbf{x}, t),  \\
% heat
h_{\alpha}(\textbf{x} + \textbf{e}\delta t, t + \delta t ) 
& = & 
\mathbb{M}^{-1} \mathbb{N}^{-1} \boldsymbol{\tilde{\Upsilon}}^{H,*}_{\alpha}(\textbf{x}, t).
\end{eqnarray}
$$

## ** Model Creation in TCLB **

## Dynamics.R

Take the one from the [basic D2Q9 Heat Transfer tutorial](/tutorials/model-development/4.-D2Q9-HeatTransfer) 
and add a new node type `AddNodeType("CM","COLLISION")`, since we are going to implement a new collision kernel.

## Dynamics.c

First we have to load R symbols.

```c
<?R
	source("conf.R") 
	source("lib/boundary.R")
	c_header();

# Creating variables for symbolic computations
	f = PV(DensityAll$name[DensityAll$group=="f"])
	h = PV(DensityAll$name[DensityAll$group=="h"])
	rho =  PV("rho")
	u = PV(c("ux","uy"))
	rhoT = PV("rhoT")

# Extracting velocity set
	U = d2q9

?>
```

### Macroscopic Quantities

Now we can replace the tedious and error-prone operarions from the [previous tutorial](/tutorials/model-development/4.-D2Q9-HeatTransfer) 
with their symbolic equivalents. Using `R` language:

```c
CudaDeviceFunction real_t getRho(){
	return <?R C(sum(f)) ?>; // compiles to f[8]+f[7]+f[6]+f[5]+f[4]+f[3]+f[2]+f[1]+f[0];
}

CudaDeviceFunction real_t getT(){
	return (<?R C(sum(h)) ?>)/(<?R C(sum(f)) ?>);
}
    
CudaDeviceFunction vector_t getRawU(){
	real_t d = getRho();
	vector_t u;
<?R C(PV(c("u.x","u.y", "u.z")), f %*% U) ?>
	u.x /= d;
	u.y /= d;
	u.z = 0;
	return u;
}

CudaDeviceFunction vector_t getU()
{
	real_t localTemperature = getT();
	vector_t u = getRawU();
	real_t m00 = getRho();
	vector_t Force = getForce(localTemperature, m00);
	u.x += Force.x/(2*m00);
	u.y += Force.y/(2*m00);
	u.z = 0;
	return u;
}
```

### Collision

```c
CudaDeviceFunction void CollisionCM()
{
	real_t localTemperature = getT();
	real_t m00 = getRho();

	vector_t Force = getForce(localTemperature, m00);
	vector_t u = getRawU();
	u.x += Force.x/(2*m00);
	u.y += Force.y/(2*m00);

	relax_and_collide_hydro_with_F(f, omega_nu, u, Force);
	relax_and_collide_ADE(h, omega_k, u);

	// equilibrium scheme for BC
	// see chapter 5.3.4.2, eq 5.34, p191 from 'The Lattice Boltzmann Method: Principles and Practice'
	// by T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen
	if ((NodeType & NODE_ADDITIONALS) == NODE_HeaterDirichletTemperature) 
	{
		// we are after collision in this if-scope {}
		real_t d_rhoT = m00*(InitTemperature - localTemperature);
		real_t h_source[9];
		set_eq(h_source, d_rhoT, u);

		for (int i = 0; i < 9; i++) {
			h[i] += h_source[i];
		}
	}

	if ((NodeType & NODE_ADDITIONALS) == NODE_HeaterNeumannHeatFlux) 
	{
		// TCLB is smart enough to distiguish values prescribed it batch.xml like
		// InitTemperature-dirichlet_region="123"
		// InitTemperature-neumann_heater_region="456"
		real_t d_rhoT = m00*InitTemperature;  
		real_t h_source[9];
		set_eq(h_source, d_rhoT, u); 
		for (int i = 0; i < 9; i++) {
			h[i] += h_source[i];}
	}
}
```

We are going to implement following functions in Central Moments Space:

```c
CudaDeviceFunction void SetEquilibrium(real_t x_in[9], real_t rho_Xeq, vector_t u){...}
CudaDeviceFunction void relax_and_collide_hydro_with_F(real_t x_in[9], real_t omega_nu, vector_t u, vector_t F){...}
CudaDeviceFunction void relax_and_collide_ADE(real_t x_in[9], real_t omega_ade, vector_t u) {...}
```

## Symbolic Operations with python

### Theory

We are going to show how the moments of Force and equilibrium distribution function can be calculated.

The formulas for the discrete equilibrium distribution function \( f^{eq} \) from previous tutorials
comes from a discretization of continous Maxwell-Boltzmann distribution function.
The Maxwell-Boltzmann equilibrium distribution function in a continuous, velocity space is known as:

$$
\begin{eqnarray}  
\Psi^{\textit{M-B, eq}} = 
\Psi^{\textit{M-B, eq}}(\psi, \boldsymbol{\xi}, \boldsymbol{u}) =
\dfrac{\psi}{(2 \pi c_s^2)^{D/2}} 
exp \left[
-\frac{(\boldsymbol{\xi}-\boldsymbol{u})^2}{2 c_s^2}
\right] \label{eq:Maxwellian}
\end{eqnarray}
$$

Where \( \psi \)  is the quantity of interest (like density or enthalpy) and \( D )is the number of dimensions.
The continuous definition of the central moments is:

$$
\begin{eqnarray}  
\tilde{\kappa}_{mn} = \int_{-\infty}^{\infty} \int_{-\infty}^{\infty}
(\xi_x - u_x)^m (\xi_y -u_y)^n
\Psi(\psi, \boldsymbol{\xi}, \boldsymbol{u}) 
d \xi_x d \xi_y \label{eq:cont_cm_mom_def}
\end{eqnarray}
$$

Now, we will discuss transformation of forcing term.

To compute the continuous transform, a scheme proposed by He et al. [^6] was expressed in a continous form by Premnath al. [^7].

$$
\begin{eqnarray}  
\Delta \boldsymbol{F}_{He} &=& \dfrac{\boldsymbol{F}}{\rho} \cdot
\nabla_u
\Psi^{\textit{M-B, eq}}(k_{00}, \boldsymbol{\xi}, \boldsymbol{u})
\nonumber  \\
\,  &=& 
 \dfrac{\boldsymbol{F}}{\rho} \cdot
 \frac{{(\boldsymbol{\xi}}-\boldsymbol{u})}{c_s^2}  
\Psi^{\textit{M-B, eq}}(k_{00}, \boldsymbol{\xi}, \boldsymbol{u}) \label{eq:He_force_cont}
\end{eqnarray}
$$

### Practise

Although it is possible to inject python snippets using `<?python />` within TCLB code, we will run the symbolic calculations in PyCharm enviroment then copy-paste the output.

Clone the repository containing TCLB tools:

```bash
git clone https://github.com/CFD-GO/TCLB_tools.git
```

Then open the `TCLB_tools/Python/symbolic_tools/` directory in PyCharm and create a new pycharm-project.
Next, create a folder `tutorials` and add a new python script `tutorial_cm_eq_derivation.py`
Run the script.

```py
from SymbolicCollisions.core.printers import print_as_vector
from sympy.matrices import Matrix
from sympy import Symbol
from SymbolicCollisions.core.ContinousCMTransforms import ContinousCMTransforms, get_mom_vector_from_continuous_def
from SymbolicCollisions.core.cm_symbols import \
    F3D, dzeta3D, u3D, rho

from SymbolicCollisions.core.cm_symbols import rho, moments_dict
import time


lattice = 'D2Q9'
ccmt = ContinousCMTransforms(dzeta3D, u3D, F3D, rho)

start = time.process_time()

print('\n\n// === continous cm === \n ')

# to calculate particular moment
row = moments_dict['D2Q9'][0]
moment = ccmt.get_cm(row, ccmt.get_Maxwellian_DF)
print_as_vector(Matrix([moment]), 'particular_moment')


print('\n//Force -> Force_cm - from continous definition: \n'
      'k_mn = integrate(fun, (x, -oo, oo), (y, -oo, oo)) \n'
      'where fun = forceM(rho,u,x,y) *(x-ux)^m *(y-uy)^n *(z-uz)^o ')
F_cm = get_mom_vector_from_continuous_def(ccmt.get_force_He_MB,
                                          continuous_transformation=ccmt.get_cm,
                                          moments_order=moments_dict[lattice])
print_as_vector(F_cm, 'F_cm')


print('\n//population_eq -> cm_eq - from continous definition: \n'
      'k_mn = integrate(fun, (x, -oo, oo), (y, -oo, oo)) \n'
      'where fun = fM(rho,u,x,y) *(x-ux)^m *(y-uy)^n *(z-uz)^o ')
cm_eq = get_mom_vector_from_continuous_def(ccmt.get_Maxwellian_DF,
                                           continuous_transformation=ccmt.get_cm,
                                           moments_order=moments_dict[lattice])
print_as_vector(cm_eq, 'cm_eq')


print(f'\n\n Done in {time.process_time() - start} [s].')
```

!!! question
    Why the python's timer doesn't work as expected?

It turns out the obtained formulas are simple, thus the numerical effort of Cascaded collision is similar to SRT (~ +10%).
As it takes a while to compute the integrals, the result is hardcoded and used afterwards for symbolic code generation.

### Collision Kernel

Task generete the missing functions:
```c
CudaDeviceFunction void SetEquilibrium(real_t x_in[9], real_t rho_Xeq, vector_t u){...}
CudaDeviceFunction void relax_and_collide_hydro_with_F(real_t x_in[9], real_t omega_nu, vector_t u, vector_t F){...}
CudaDeviceFunction void relax_and_collide_ADE(real_t x_in[9], real_t omega_ade, vector_t u) {...}
```

Create a new python script `tutorial_cm_collision.py`.
Fill the missing functionalities `#TODO`


```python
from sympy.matrices import eye
from sympy.printing import print_ccode
from SymbolicCollisions.core.cm_symbols import omega_ade, omega_b, omega_v, m00
from SymbolicCollisions.core.cm_symbols import dynamic_import
from SymbolicCollisions.core.DiscreteCMTransforms import get_DF, get_m00
from SymbolicCollisions.core.printers import print_u2, print_as_vector
from SymbolicCollisions.core.MatrixGenerator import get_raw_moments_matrix, get_shift_matrix

# inspired by:
# "Consistent Forcing Scheme in the cascaded LBM" L. Fei et al. 2017
# eqs 8-12 : (eye(q)-S)*cm + S*cm_eq + (eye(q)-S/2.)*force_in_cm_space

# SETUP
d = 2
q = 9
model = 'hydro'  # choose from '['hydro', 'ade']

# DYNAMIC IMPORTS
ex = dynamic_import("SymbolicCollisions.core.cm_symbols", f"ex_D{d}Q{q}")
ey = dynamic_import("SymbolicCollisions.core.cm_symbols", f"ey_D{d}Q{q}")
if d == 3:
    ez = dynamic_import("SymbolicCollisions.core.cm_symbols", f"ez_D{d}Q{q}")
else:
    ez = None


def get_s_relax_switcher(choice):
    s_relax_switcher = {
        'hydro': ("SymbolicCollisions.core.cm_symbols", f"S_relax_hydro_D{d}Q{q}"),
        'ade': ("SymbolicCollisions.core.cm_symbols", f"S_relax_ADE_D{d}Q{q}"),
    }
    which_model = s_relax_switcher.get(choice, lambda: "Invalid argument")
    return dynamic_import(*which_model)


S_Relax = get_s_relax_switcher(model)

hardcoded_cm_eq = dynamic_import("SymbolicCollisions.core.hardcoded_results", f"hardcoded_cm_eq_compressible_D{d}Q{q}")
hardcoded_F_cm = dynamic_import("SymbolicCollisions.core.hardcoded_results", f"hardcoded_F_cm_pf_D{d}Q{q}")
from SymbolicCollisions.core.cm_symbols import Force_str as F_str

# ARRANGE STUFF
Mraw = get_raw_moments_matrix(ex, ey, ez)
Nraw = get_shift_matrix(Mraw.inv(), ex, ey, ez)

# from sympy import pprint
# pprint(Mraw)  # see what you have done
# pprint(Nraw)

pop_in_str = 'x_in'  # symbol defining populations
temp_pop_str = 'temp'  # symbol defining populations
cm_eq_pop_str = 'cm_eq'  # symbol defining populations


# GENERATE CODE
def make_header(choice):
    model_switcher = {
        'hydro': f"CudaDeviceFunction void relax_and_collide_hydro_with_F(real_t {pop_in_str}[{q}], real_t {omega_v}, vector_t u, vector_t {F_str}) \n{{",
        'ade': f"CudaDeviceFunction void relax_and_collide_ADE(real_t {pop_in_str}[{q}], real_t {omega_ade}, vector_t u) \n{{",
    }
    result = model_switcher.get(choice, lambda: "Invalid argument")
    print(result)


make_header(model)

print("\t//=== THIS IS AUTOMATICALLY GENERATED CODE ===")
print_u2(d)
print_ccode(get_m00(q, pop_in_str), assign_to=f'\treal_t {m00}')


def make_variables(choice):
    model_switcher = {
        'hydro': f"\n\treal_t {temp_pop_str}[{q}];\n",
        'ade': f"\n\treal_t {temp_pop_str}[{q}];\n",
    }
    # Get the function from switcher dictionary
    result = model_switcher.get(choice, lambda: "Invalid argument")
    print(result)


make_variables(model)

print(f"\tfor (int i = 0; i < {q}; i++) {{\n\t"
      f"\t{temp_pop_str}[i] = {pop_in_str}[i];}}")

populations = get_DF(q, pop_in_str)
temp_populations = get_DF(q, temp_pop_str)
cm_eq = get_DF(q, cm_eq_pop_str)
F_cm = get_DF(q, F_str)
m = Mraw * temp_populations

print("\n\t//raw moments from density-probability functions")
# print("\t//[m00, m10, m01, m20, m02, m11, m21, m12, m22]")
print_as_vector(m, print_symbol=pop_in_str)

print("\n\t//central moments from raw moments")
cm = Nraw * populations
print_as_vector(cm, print_symbol=temp_pop_str)

print("\n\t//collision in central moments space")
print("\t//collide")


def make_collision(choice):
    model_switcher = {
        # Relax 2nd moments for hydro, SOI
        'hydro': (eye(q) - S_Relax) * temp_populations
                 + S_Relax * hardcoded_cm_eq
                 + (eye(q) - S_Relax / 2) * hardcoded_F_cm,
        # Relax 1st moments for ADE, SOI without force
        'ade': None  # TODO: write the collision for advection-diffusion equation
    }
    # Get the function from switcher dictionary
    cm_after_collision = model_switcher.get(choice, lambda: "Invalid argument")
    print_as_vector(cm_after_collision, print_symbol=pop_in_str)


make_collision(model)

print("\n\t//back to raw moments")
# TODO: write 2 lines of code to
#  - reverse-transform central moments to raw moments
#  - print the result as c code;

print("\n\t//back to density-probability functions")
# TODO: write 2 lines of code to
#  - reverse-transform raw moments to density-probability functions
#  - print the result as c code;


print("\n}\n")

```

Hint:
After the collision, the central moments have to be back-tranformed to moments, 
then to density-probability functions - see the [streaming](#streaming) step.

## Setting up a Simulation

To run the new collision kernel, change the configuration file, `my_heat_cube.xml` from [previous tutorial](/tutorials/model-development/4.-D2Q9-HeatTransfer) :
`<BGK><Box /></BGK>` to `<CM><Box /></CM>`.  

Finally, you may try a another geometry to see how the BC behavies

```xml
<?xml version="1.0"?>
<CLBConfig version="2.0" output="output/">
      <Geometry nx="500" ny="100" >
      <CM><Box /></CM>    
        <None name="heated_region">
            <Sphere dx="175" nx="50" dy="25" ny="50" /> 
        </None>        

        <Solid name="solid_region">
          <Box dx="100" dy="50" nx="20" ny="25"/>
        </Solid>

        <Wall mask="ALL" name="box" >     
           <Box dx="100" dy="25" nx="20" ny="25"/>
        </Wall>

        <HeaterDirichletTemperature  name="dirichlet_region"> 
          <Box dx="200" dy="50" nx="20" ny="25"/>
        </HeaterDirichletTemperature>
        
        <HeaterNeumannHeatFlux  name="neumann_heater_region"> 
          <Box dx="300" dy="25" nx="20" ny="25"/>
        </HeaterNeumannHeatFlux>
        <HeaterNeumannHeatFlux  name="neumann_cool_region"> 
          <Box dx="350" dy="50" nx="20" ny="25"/>
        </HeaterNeumannHeatFlux>

      	<Solid name="solid_region">
      	  <Box dx="400" dy="10" nx="20" ny="40"/>
      	</Solid>

  </Geometry>
    <Model>
    <Params
        k="0.1666666" 
        cp="1.0"

        InitTemperature="0.0"
        InitTemperature-heated_region="10"
        InitTemperature-dirichlet_region="100.0"

        InitTemperature-neumann_heater_region="1E0"
        InitTemperature-neumann_cool_region="-1E0"
        />
    <Params  />
    <Params GravitationX="-1.0E-5" />
    <!-- <Params GravitationY="-1.0E-7" /> -->
    <!-- <Params BoussinesqCoeff="1"/> -->
    <!-- <Params VelocityX="-1.0E-1" /> -->

    </Model> 

<Solve Iterations="10" output="output/"> <VTK Iterations="1"/> </Solve>
<Failcheck Iterations="10" nx="500" ny="100" />
<Log Iterations="1000"/>
<Solve Iterations="20000" output="output/"> <VTK Iterations="250"/> </Solve>
</CLBConfig>
```

## References

!!! tip
		A good starting point explaining the 'zoo' of various LBM models is a modern (2017) book
		'The Lattice Boltzmann Method: Principles and Practice'
		written by  T. Krüger, H. Kusumaatmaja, A. Kuzmin, O. Shardt, G. Silva, E.M. Viggen .

The implementation of the cascaded collision kernel is greatly insipered by the work of Linlin Fei, Kai H. Luo et al.

[^1]: Linlin Fei, Kai Hong Luo, 'Cascaded lattice Boltzmann method for incompressible thermal flows with heat sources and general thermal boundary conditions' Computers and Fluids (2018).

[^2]: Linlin Fei, Kai Hong Luo, Chuandong Lin, Qing Li, 'Modeling incompressible thermal flows using a central-moments-based lattice Boltzmann method' International Journal of Heat and Mass Transfer (2017).

[^3]: Linlin Fei and Kai Hong Luo, 'Consistent forcing scheme in the cascaded lattice Boltzmann method' Physical Review E 96, 053307 (2017).

[^4]: Linlin Fei, Kai H. Luo and Qing Li, 'Three-dimensional cascaded lattice Boltzmann method: Improved implementation and consistent forcing scheme' Physical Review E 97, 053309 (2018)

[^5]: M. Geier, A. Greiner, J. G. Korvink, 'Cascaded digital lattice Boltzmann automata for high Reynolds number flow' Physical Review E - Statistical, Nonlinear, and Soft Matter Physics 73 (2006).

[^6]: Xiaoyi He, Xiaowen Shan, and Gary D. Doolen, 'Discrete Boltzmann equation model for nonideal gases' in Physical Review E - Statistical Physics, Plasmas, Fluids, and Related Interdisciplinary Topics (1998).

[^7]: K. N. Premnath, S. Banerjee, 'Incorporating forcing terms in cascaded lattice Boltzmann approach by method of central moments' in Physical Review E - Statistical, Nonlinear, and Soft Matter Physics 80 (2009).